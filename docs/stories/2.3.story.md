# Story 2.3: Serviço de Gestão de Parcelas

## Status: Draft

## Story

**As a** administrador,
**I want** funções para consultar, filtrar e dar baixa em parcelas,
**so that** eu possa gerenciar os recebíveis do negócio.

## Acceptance Criteria

1. Função `getInstallmentsBySale(saleId)` retorna parcelas de uma venda
2. Função `getInstallmentsByCustomer(customerId)` retorna parcelas do cliente
3. Função `getPendingInstallments(filters)` com filtros de período e status
4. Função `getOverdueInstallments()` retorna parcelas vencidas
5. Função `payInstallment(id, amount, method)` registra pagamento
6. Ao pagar parcela, registro automático no `cash_flow`
7. Ao pagar última parcela, `payment_status` da venda atualiza para 'paid'
8. Suporte a pagamento parcial

## Integration Verification

- IV1: Queries respeitam RLS
- IV2: Performance < 500ms para consultas de até 1000 parcelas
- IV3: Não há side effects em outras tabelas além de `cash_flow`

## Tasks / Subtasks

- [ ] **Task 1: Implementar `getInstallmentsBySale`** (AC: 1)
  - [ ] Query em sale_installments filtrando por sale_id
  - [ ] Ordenar por installment_number ASC
  - [ ] Retornar array de Installment

- [ ] **Task 2: Implementar `getInstallmentsByCustomer`** (AC: 2)
  - [ ] Join: sale_installments → sales → customer_id
  - [ ] Filtrar por customer_id
  - [ ] Incluir dados da venda (total_amount, created_at)
  - [ ] Ordenar por due_date ASC

- [ ] **Task 3: Implementar `getPendingInstallments`** (AC: 3)
  - [ ] Aceitar filtros: status[], dueDateFrom, dueDateTo, customerId, saleId
  - [ ] Join com sales e customers para dados completos
  - [ ] Filtros condicionais baseados nos parâmetros
  - [ ] Ordenar por due_date ASC
  - [ ] Retornar com dados de customer (full_name, whatsapp)

- [ ] **Task 4: Implementar `getOverdueInstallments`** (AC: 4)
  - [ ] Filtrar: status IN ('pending', 'partial') AND due_date < hoje
  - [ ] Join com sales e customers
  - [ ] Ordenar por due_date ASC (mais antigas primeiro)
  - [ ] Retornar com dados completos

- [ ] **Task 5: Implementar `getInstallmentsSummary`** (AC: 3)
  - [ ] Calcular totalPending: SUM(amount - paid_amount) WHERE status IN ('pending', 'partial')
  - [ ] Calcular totalOverdue: SUM(amount - paid_amount) WHERE status = 'overdue'
  - [ ] Calcular countPending, countOverdue
  - [ ] Calcular dueThisWeek: próximos 7 dias
  - [ ] Calcular dueThisMonth: mês atual

- [ ] **Task 6: Implementar `payInstallment`** (AC: 5, 6, 7, 8)
  - [ ] Aceitar: installmentId, amount, paymentMethod, paidAt?, notes?
  - [ ] Buscar parcela atual
  - [ ] Validar: amount <= (parcela.amount - parcela.paid_amount)
  - [ ] Atualizar parcela:
    - [ ] paid_amount += amount
    - [ ] Se paid_amount >= amount: status = 'paid'
    - [ ] Senão: status = 'partial'
    - [ ] paid_at = paidAt ou now()
    - [ ] payment_method = paymentMethod
  - [ ] Criar entry no cash_flow (category: 'installment_payment')
  - [ ] Trigger automático atualiza payment_status da venda

- [ ] **Task 7: Criar Triggers no Banco** (AC: 7)
  - [ ] Função `update_sale_payment_status()` - conta parcelas pagas vs total
  - [ ] Trigger AFTER UPDATE OF status ON sale_installments
  - [ ] Atualiza sales.payment_status baseado em proporção

- [ ] **Task 8: Verificação de Integração** (IV1, IV2, IV3)
  - [ ] Testar RLS: usuário A não vê parcelas de usuário B
  - [ ] Testar performance com volume
  - [ ] Verificar que apenas cash_flow é afetado ao pagar

## Dev Notes

### Dependências

- **Requer**: Story 2.1 (tabelas) e Story 2.2 (createInstallmentsForSale, createCashFlowEntry)
- **Arquivo**: `lib/services/installmentService.ts` (expandir)

### Interfaces Completas

[Source: docs/architecture-cash-flow.md#5.1.1]

```typescript
// lib/services/installmentService.ts

export interface Installment {
  id: string
  sale_id: string
  user_id: string
  installment_number: number
  amount: number
  due_date: string
  status: 'pending' | 'paid' | 'partial' | 'overdue' | 'cancelled'
  paid_amount: number
  paid_at: string | null
  payment_method: string | null
  notes: string | null
  created_at: string
  updated_at: string
  // Joins opcionais
  sale?: {
    id: string
    total_amount: number
    customer_id: string
    created_at: string
  }
  customer?: {
    id: string
    full_name: string
    whatsapp: string
  }
}

export interface InstallmentFilters {
  status?: Installment['status'][]
  dueDateFrom?: Date
  dueDateTo?: Date
  customerId?: string
  saleId?: string
}

export interface PayInstallmentInput {
  installmentId: string
  amount: number
  paymentMethod: 'pix' | 'cash'
  paidAt?: Date
  notes?: string
}

export interface InstallmentSummary {
  totalPending: number
  totalOverdue: number
  countPending: number
  countOverdue: number
  dueThisWeek: number
  dueThisMonth: number
}
```

### Implementações das Funções

```typescript
// getInstallmentsBySale
export async function getInstallmentsBySale(saleId: string): Promise<Installment[]> {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  const { data, error } = await supabase
    .from('sale_installments')
    .select('*')
    .eq('sale_id', saleId)
    .order('installment_number', { ascending: true })

  if (error) throw error
  return data || []
}

// getInstallmentsByCustomer
export async function getInstallmentsByCustomer(customerId: string): Promise<Installment[]> {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  const { data, error } = await supabase
    .from('sale_installments')
    .select(`
      *,
      sale:sales!inner(id, total_amount, customer_id, created_at)
    `)
    .eq('sales.customer_id', customerId)
    .order('due_date', { ascending: true })

  if (error) throw error
  return data || []
}

// getPendingInstallments
export async function getPendingInstallments(
  filters?: InstallmentFilters
): Promise<Installment[]> {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  let query = supabase
    .from('sale_installments')
    .select(`
      *,
      sale:sales(id, total_amount, customer_id),
      customer:sales(customers(id, full_name, whatsapp))
    `)

  // Aplicar filtros
  if (filters?.status?.length) {
    query = query.in('status', filters.status)
  } else {
    query = query.in('status', ['pending', 'partial', 'overdue'])
  }

  if (filters?.dueDateFrom) {
    query = query.gte('due_date', filters.dueDateFrom.toISOString().split('T')[0])
  }

  if (filters?.dueDateTo) {
    query = query.lte('due_date', filters.dueDateTo.toISOString().split('T')[0])
  }

  if (filters?.customerId) {
    query = query.eq('sales.customer_id', filters.customerId)
  }

  if (filters?.saleId) {
    query = query.eq('sale_id', filters.saleId)
  }

  query = query.order('due_date', { ascending: true })

  const { data, error } = await query
  if (error) throw error
  return data || []
}

// getOverdueInstallments
export async function getOverdueInstallments(): Promise<Installment[]> {
  const supabase = createClient()
  const today = new Date().toISOString().split('T')[0]

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  const { data, error } = await supabase
    .from('sale_installments')
    .select(`
      *,
      sale:sales(id, total_amount, customer_id),
      customer:sales(customers(id, full_name, whatsapp))
    `)
    .in('status', ['pending', 'partial'])
    .lt('due_date', today)
    .order('due_date', { ascending: true })

  if (error) throw error
  return data || []
}

// payInstallment
export async function payInstallment(input: PayInstallmentInput): Promise<Installment> {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  // Buscar parcela atual
  const { data: current, error: fetchError } = await supabase
    .from('sale_installments')
    .select('*')
    .eq('id', input.installmentId)
    .single()

  if (fetchError || !current) throw new Error('Parcela não encontrada')

  // Validar valor
  const remaining = current.amount - current.paid_amount
  if (input.amount > remaining) {
    throw new Error(`Valor máximo permitido: R$ ${remaining.toFixed(2)}`)
  }

  // Calcular novo status
  const newPaidAmount = current.paid_amount + input.amount
  const newStatus = newPaidAmount >= current.amount ? 'paid' : 'partial'

  // Atualizar parcela
  const { data: updated, error: updateError } = await supabase
    .from('sale_installments')
    .update({
      paid_amount: newPaidAmount,
      status: newStatus,
      paid_at: (input.paidAt || new Date()).toISOString(),
      payment_method: input.paymentMethod,
      notes: input.notes || current.notes,
      updated_at: new Date().toISOString()
    })
    .eq('id', input.installmentId)
    .select()
    .single()

  if (updateError) throw updateError

  // Registrar no cash_flow
  await createCashFlowEntry({
    type: 'income',
    category: 'installment_payment',
    amount: input.amount,
    description: `Parcela ${current.installment_number} - Venda ${current.sale_id}`,
    referenceType: 'installment',
    referenceId: input.installmentId,
    transactionDate: input.paidAt
  })

  return updated
}

// getInstallmentsSummary
export async function getInstallmentsSummary(): Promise<InstallmentSummary> {
  const supabase = createClient()
  const today = new Date()
  const weekFromNow = new Date(today)
  weekFromNow.setDate(weekFromNow.getDate() + 7)
  const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0)

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  // Query para totais
  const { data, error } = await supabase
    .from('sale_installments')
    .select('amount, paid_amount, status, due_date')
    .in('status', ['pending', 'partial', 'overdue'])

  if (error) throw error

  const todayStr = today.toISOString().split('T')[0]
  const weekStr = weekFromNow.toISOString().split('T')[0]
  const monthStr = endOfMonth.toISOString().split('T')[0]

  const summary: InstallmentSummary = {
    totalPending: 0,
    totalOverdue: 0,
    countPending: 0,
    countOverdue: 0,
    dueThisWeek: 0,
    dueThisMonth: 0
  }

  data?.forEach(item => {
    const remaining = item.amount - item.paid_amount
    const isOverdue = item.due_date < todayStr

    if (isOverdue) {
      summary.totalOverdue += remaining
      summary.countOverdue++
    } else {
      summary.totalPending += remaining
      summary.countPending++

      if (item.due_date <= weekStr) {
        summary.dueThisWeek += remaining
      }
      if (item.due_date <= monthStr) {
        summary.dueThisMonth += remaining
      }
    }
  })

  return summary
}
```

### Trigger para Atualizar Status da Venda

[Source: docs/architecture-cash-flow.md#4.4.2]

```sql
-- Já deve existir da Story 2.1, mas verificar:

CREATE OR REPLACE FUNCTION update_sale_payment_status()
RETURNS TRIGGER AS $$
DECLARE
  total_installments INTEGER;
  paid_installments INTEGER;
BEGIN
  SELECT
    COUNT(*),
    COUNT(*) FILTER (WHERE status = 'paid')
  INTO total_installments, paid_installments
  FROM sale_installments
  WHERE sale_id = NEW.sale_id;

  UPDATE sales
  SET
    payment_status = CASE
      WHEN paid_installments = total_installments THEN 'paid'
      WHEN paid_installments > 0 THEN 'partial'
      ELSE 'pending'
    END,
    updated_at = NOW()
  WHERE id = NEW.sale_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_update_sale_payment_status
  AFTER UPDATE OF status ON sale_installments
  FOR EACH ROW
  WHEN (OLD.status IS DISTINCT FROM NEW.status)
  EXECUTE FUNCTION update_sale_payment_status();
```

### Padrão de Error Handling

```typescript
try {
  // ... operação
} catch (error) {
  console.error('Error in functionName:', error)
  throw new Error('Mensagem amigável em português')
}
```

### Testing

- Testar `getInstallmentsBySale` com venda existente
- Testar `getPendingInstallments` com diferentes filtros
- Testar `payInstallment` com valor total e parcial
- Verificar que trigger atualiza payment_status da venda
- Verificar criação de entry no cash_flow

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-29 | 1.0 | Story criada a partir do PRD | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_A ser preenchido pelo dev agent_

### Debug Log References
_A ser preenchido pelo dev agent_

### Completion Notes
_A ser preenchido pelo dev agent_

### File List
_A ser preenchido pelo dev agent_

---

## QA Results
_A ser preenchido pelo QA agent_
