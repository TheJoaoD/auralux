# Story 2.2: Geração Automática de Parcelas na Venda

## Status: Draft

## Story

**As a** vendedor,
**I want** que parcelas sejam criadas automaticamente ao registrar venda parcelada,
**so that** eu não precise cadastrar cada parcela manualmente.

## Acceptance Criteria

1. Ao criar venda com `payment_method: 'installment'`, parcelas são geradas automaticamente
2. Número de parcelas corresponde ao `installment_count` da venda
3. Datas de vencimento são calculadas mensalmente a partir da data da venda
4. Valor de cada parcela é calculado corretamente: `(total - entrada) / parcelas`
5. Campo de entrada/sinal disponível na UI de pagamento
6. Se entrada > 0, registro imediato no `cash_flow` como income
7. `payment_status` da venda é setado como 'partial' ou 'pending' conforme entrada
8. Vendas à vista registram diretamente no `cash_flow` com status 'paid'

## Integration Verification

- IV1: Fluxo de venda à vista continua funcionando normalmente
- IV2: Triggers de cliente executam corretamente
- IV3: Rollback funciona: se falhar criar parcelas, venda não é criada

## Tasks / Subtasks

- [ ] **Task 1: Criar função `createInstallmentsForSale`** (AC: 1, 2, 3, 4)
  - [ ] Criar arquivo `lib/services/installmentService.ts`
  - [ ] Implementar função que recebe: saleId, totalAmount, downPayment, installmentCount, startDate
  - [ ] Calcular valor de cada parcela: `(totalAmount - downPayment) / installmentCount`
  - [ ] Calcular datas de vencimento: startDate + (i-1) meses
  - [ ] Inserir parcelas na tabela `sale_installments`
  - [ ] Retornar array de parcelas criadas

- [ ] **Task 2: Criar função `createCashFlowEntry`** (AC: 6, 8)
  - [ ] Criar arquivo `lib/services/cashFlowService.ts`
  - [ ] Implementar função que recebe: type, category, amount, description, referenceType, referenceId, transactionDate
  - [ ] Inserir registro na tabela `cash_flow`
  - [ ] Retornar entrada criada

- [ ] **Task 3: Modificar `salesService.ts` - createSale()** (AC: 1, 6, 7, 8)
  - [ ] Adicionar parâmetro `down_payment` ao CreateSaleInput
  - [ ] Manter compatibilidade: se down_payment não vier, usar 0
  - [ ] Se payment_method === 'installment':
    - [ ] Setar payment_status = down_payment > 0 ? 'partial' : 'pending'
    - [ ] Setar down_payment no registro da venda
    - [ ] Chamar createInstallmentsForSale()
    - [ ] Se down_payment > 0, chamar createCashFlowEntry() com category='sale_down_payment'
  - [ ] Se payment_method !== 'installment' (à vista):
    - [ ] Setar payment_status = 'paid'
    - [ ] Chamar createCashFlowEntry() com category='sale_cash'

- [ ] **Task 4: Atualizar UI de Pagamento** (AC: 5)
  - [ ] Localizar componente de finalização de venda
  - [ ] Adicionar campo "Entrada/Sinal" (só aparece quando payment_method === 'installment')
  - [ ] Validar: entrada não pode ser maior que total
  - [ ] Mostrar cálculo em tempo real: "3x de R$ X" baseado em (total - entrada) / parcelas

- [ ] **Task 5: Atualizar Schema Zod** (AC: 1, 5)
  - [ ] Adicionar campo down_payment ao schema de venda
  - [ ] Validar: down_payment >= 0 e down_payment < total_amount

- [ ] **Task 6: Verificação de Integração** (IV1, IV2, IV3)
  - [ ] Testar venda à vista: deve criar cash_flow entry, payment_status='paid'
  - [ ] Testar venda parcelada sem entrada: parcelas criadas, payment_status='pending'
  - [ ] Testar venda parcelada com entrada: cash_flow entry para entrada, parcelas criadas
  - [ ] Verificar trigger de cliente (purchase_count, total_purchases)
  - [ ] Testar rollback: simular erro ao criar parcelas, verificar que venda não é criada

## Dev Notes

### Dependências

- **Requer**: Story 2.1 completa (tabelas existentes)
- **Arquivos a criar**: `lib/services/installmentService.ts`, `lib/services/cashFlowService.ts`
- **Arquivos a modificar**: `lib/services/salesService.ts`

### Estrutura do installmentService.ts

[Source: docs/architecture-cash-flow.md#5.1.1]

```typescript
// lib/services/installmentService.ts
import { createClient } from '@/lib/supabase/client'

export interface Installment {
  id: string
  sale_id: string
  user_id: string
  installment_number: number
  amount: number
  due_date: string
  status: 'pending' | 'paid' | 'partial' | 'overdue' | 'cancelled'
  paid_amount: number
  paid_at: string | null
  payment_method: string | null
  notes: string | null
  created_at: string
  updated_at: string
}

export async function createInstallmentsForSale(
  saleId: string,
  totalAmount: number,
  downPayment: number,
  installmentCount: number,
  startDate: Date
): Promise<Installment[]> {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  const parcelableAmount = totalAmount - downPayment
  const installmentAmount = Number((parcelableAmount / installmentCount).toFixed(2))

  // Ajustar última parcela para diferença de arredondamento
  const installments = []
  let remainingAmount = parcelableAmount

  for (let i = 1; i <= installmentCount; i++) {
    const isLast = i === installmentCount
    const amount = isLast ? remainingAmount : installmentAmount
    remainingAmount -= amount

    const dueDate = new Date(startDate)
    dueDate.setMonth(dueDate.getMonth() + (i - 1))

    installments.push({
      sale_id: saleId,
      user_id: user.id,
      installment_number: i,
      amount: amount,
      due_date: dueDate.toISOString().split('T')[0],
      status: 'pending',
      paid_amount: 0
    })
  }

  const { data, error } = await supabase
    .from('sale_installments')
    .insert(installments)
    .select()

  if (error) throw error
  return data || []
}
```

### Estrutura do cashFlowService.ts

[Source: docs/architecture-cash-flow.md#5.1.2]

```typescript
// lib/services/cashFlowService.ts
import { createClient } from '@/lib/supabase/client'

export interface CashFlowEntry {
  id: string
  user_id: string
  type: 'income' | 'expense'
  category: string
  amount: number
  description: string | null
  reference_type: string | null
  reference_id: string | null
  transaction_date: string
  created_at: string
}

export async function createCashFlowEntry(input: {
  type: 'income' | 'expense'
  category: string
  amount: number
  description?: string
  referenceType?: string
  referenceId?: string
  transactionDate?: Date
}): Promise<CashFlowEntry> {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  const { data, error } = await supabase
    .from('cash_flow')
    .insert({
      user_id: user.id,
      type: input.type,
      category: input.category,
      amount: input.amount,
      description: input.description || null,
      reference_type: input.referenceType || null,
      reference_id: input.referenceId || null,
      transaction_date: (input.transactionDate || new Date()).toISOString().split('T')[0],
      created_by: user.id
    })
    .select()
    .single()

  if (error) throw error
  return data
}
```

### Modificação do createSale

[Source: docs/architecture-cash-flow.md#6.3]

```typescript
// Em lib/services/salesService.ts

export interface CreateSaleInput {
  customer_id: string
  cartItems: Array<{...}>
  payment_method: 'pix' | 'cash' | 'installment'
  installment_count?: number
  actual_amount_received?: number
  down_payment?: number  // NOVO
  notes?: string
}

// Dentro de createSale():

// Determinar payment_status
const paymentStatus = input.payment_method === 'installment'
  ? (input.down_payment && input.down_payment > 0 ? 'partial' : 'pending')
  : 'paid'

// Inserir venda com novos campos
const sale = await supabase.from('sales').insert({
  ...existingFields,
  payment_status: paymentStatus,
  down_payment: input.down_payment || 0
})

// Após criar venda e itens...

// Se parcelado, criar parcelas
if (input.payment_method === 'installment' && input.installment_count) {
  await createInstallmentsForSale(
    sale.id,
    totalAmount,
    input.down_payment || 0,
    input.installment_count,
    new Date()
  )

  // Se tem entrada, registrar no cash_flow
  if (input.down_payment && input.down_payment > 0) {
    await createCashFlowEntry({
      type: 'income',
      category: 'sale_down_payment',
      amount: input.down_payment,
      description: `Entrada da venda ${sale.id}`,
      referenceType: 'sale',
      referenceId: sale.id
    })
  }
} else {
  // Venda à vista - registrar total no cash_flow
  await createCashFlowEntry({
    type: 'income',
    category: 'sale_cash',
    amount: totalAmount,
    description: `Venda à vista ${sale.id}`,
    referenceType: 'sale',
    referenceId: sale.id
  })
}
```

### Localização de Arquivos

[Source: docs/architecture-cash-flow.md#7]

- **Criar**: `lib/services/installmentService.ts`
- **Criar**: `lib/services/cashFlowService.ts`
- **Modificar**: `lib/services/salesService.ts`
- **Modificar**: `lib/validations/saleSchemas.ts` (se existir)
- **Modificar**: Componente de checkout/pagamento (localizar em `components/vendas/` ou similar)

### Categorias de Cash Flow

| Categoria | Uso |
|-----------|-----|
| `sale_cash` | Venda à vista (pix/dinheiro) |
| `sale_down_payment` | Entrada de venda parcelada |
| `installment_payment` | Pagamento de parcela |
| `refund` | Estorno |
| `adjustment` | Ajuste manual |
| `other` | Outros |

### Testing

- **Testes manuais**: Testar fluxo completo de venda
- **Verificações**:
  1. Venda à vista cria entry no cash_flow
  2. Venda parcelada cria N parcelas em sale_installments
  3. Entrada cria entry separado no cash_flow
  4. Datas de vencimento estão corretas (mensais)
  5. Valores das parcelas somam o total parcelável

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-29 | 1.0 | Story criada a partir do PRD | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_A ser preenchido pelo dev agent_

### Debug Log References
_A ser preenchido pelo dev agent_

### Completion Notes
_A ser preenchido pelo dev agent_

### File List
_A ser preenchido pelo dev agent_

---

## QA Results
_A ser preenchido pelo QA agent_
