# Story 2.4: Serviço de Fluxo de Caixa

## Status: Draft

## Story

**As a** administrador,
**I want** consultar o fluxo de caixa por período,
**so that** eu saiba exatamente quanto dinheiro entrou e saiu.

## Acceptance Criteria

1. Função `getCashFlowByPeriod(startDate, endDate)` retorna lançamentos
2. Função `getCashFlowSummary(period)` retorna totais de entrada/saída
3. Função `getDailyCashFlow(date)` retorna caixa do dia
4. Função `getReceivablesForecast(months)` projeta recebimentos futuros
5. Função `getCashFlowMetrics()` retorna: caixa hoje, a receber no mês, vencidas
6. Dados agrupáveis por dia, semana, mês
7. Filtro por categoria

## Integration Verification

- IV1: Métricas existentes do dashboard não são afetadas
- IV2: Queries funcionam com timezone correto
- IV3: RLS garante isolamento por usuário

## Tasks / Subtasks

- [ ] **Task 1: Expandir `cashFlowService.ts`** (AC: 1-7)
  - [ ] Adicionar interface CashFlowSummary
  - [ ] Adicionar interface CashFlowMetrics
  - [ ] Adicionar interface ReceivablesForecast

- [ ] **Task 2: Implementar `getCashFlowByPeriod`** (AC: 1, 7)
  - [ ] Query em cash_flow filtrando por transaction_date BETWEEN
  - [ ] Aceitar filtro opcional por category
  - [ ] Ordenar por transaction_date DESC
  - [ ] Retornar array de CashFlowEntry

- [ ] **Task 3: Implementar `getCashFlowSummary`** (AC: 2)
  - [ ] Aceitar startDate e endDate
  - [ ] Calcular totalIncome: SUM(amount) WHERE type = 'income'
  - [ ] Calcular totalExpense: SUM(amount) WHERE type = 'expense'
  - [ ] Calcular balance: totalIncome - totalExpense
  - [ ] Retornar com período

- [ ] **Task 4: Implementar `getDailyCashFlow`** (AC: 3)
  - [ ] Query filtrando por transaction_date = date
  - [ ] Retornar entries do dia

- [ ] **Task 5: Implementar `getReceivablesForecast`** (AC: 4)
  - [ ] Query em sale_installments WHERE status IN ('pending', 'partial')
  - [ ] Agrupar por mês (due_date)
  - [ ] Calcular expected = SUM(amount - paid_amount) por mês
  - [ ] Retornar próximos N meses

- [ ] **Task 6: Implementar `getCashFlowMetrics`** (AC: 5)
  - [ ] Calcular today: entradas de hoje
  - [ ] Calcular thisWeek: entradas dos últimos 7 dias
  - [ ] Calcular thisMonth: entradas do mês atual
  - [ ] Calcular pendingReceivables: total de parcelas pendentes
  - [ ] Calcular overdueReceivables: total de parcelas vencidas

- [ ] **Task 7: Implementar `getCashFlowGrouped`** (AC: 6)
  - [ ] Aceitar parâmetro groupBy: 'day' | 'week' | 'month'
  - [ ] Agrupar dados conforme período
  - [ ] Retornar array com período e totais

- [ ] **Task 8: Verificação de Integração** (IV1, IV2, IV3)
  - [ ] Verificar que dashboard de vendas continua funcionando
  - [ ] Testar queries com datas em diferentes timezones
  - [ ] Testar RLS: usuário A não vê cash_flow de usuário B

## Dev Notes

### Dependências

- **Requer**: Story 2.1 (tabelas), Story 2.2 e 2.3 (dados no cash_flow)
- **Arquivo**: `lib/services/cashFlowService.ts` (expandir)

### Interfaces Completas

[Source: docs/architecture-cash-flow.md#5.1.2]

```typescript
// lib/services/cashFlowService.ts

export interface CashFlowEntry {
  id: string
  user_id: string
  type: 'income' | 'expense'
  category: string
  amount: number
  description: string | null
  reference_type: string | null
  reference_id: string | null
  transaction_date: string
  created_at: string
}

export interface CashFlowSummary {
  totalIncome: number
  totalExpense: number
  balance: number
  period: {
    start: string
    end: string
  }
}

export interface CashFlowMetrics {
  today: number
  thisWeek: number
  thisMonth: number
  pendingReceivables: number
  overdueReceivables: number
}

export interface ReceivablesForecast {
  month: string  // 'YYYY-MM'
  expected: number
  count: number
}

export interface CashFlowFilters {
  startDate?: Date
  endDate?: Date
  type?: 'income' | 'expense'
  category?: string
}

export interface GroupedCashFlow {
  period: string
  income: number
  expense: number
  balance: number
  count: number
}
```

### Implementações das Funções

```typescript
// getCashFlowByPeriod
export async function getCashFlowByPeriod(
  startDate: Date,
  endDate: Date,
  filters?: { category?: string; type?: 'income' | 'expense' }
): Promise<CashFlowEntry[]> {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  let query = supabase
    .from('cash_flow')
    .select('*')
    .gte('transaction_date', startDate.toISOString().split('T')[0])
    .lte('transaction_date', endDate.toISOString().split('T')[0])

  if (filters?.category) {
    query = query.eq('category', filters.category)
  }

  if (filters?.type) {
    query = query.eq('type', filters.type)
  }

  query = query.order('transaction_date', { ascending: false })

  const { data, error } = await query
  if (error) throw error
  return data || []
}

// getCashFlowSummary
export async function getCashFlowSummary(
  startDate: Date,
  endDate: Date
): Promise<CashFlowSummary> {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  const { data, error } = await supabase
    .from('cash_flow')
    .select('type, amount')
    .gte('transaction_date', startDate.toISOString().split('T')[0])
    .lte('transaction_date', endDate.toISOString().split('T')[0])

  if (error) throw error

  let totalIncome = 0
  let totalExpense = 0

  data?.forEach(entry => {
    if (entry.type === 'income') {
      totalIncome += entry.amount
    } else {
      totalExpense += entry.amount
    }
  })

  return {
    totalIncome,
    totalExpense,
    balance: totalIncome - totalExpense,
    period: {
      start: startDate.toISOString().split('T')[0],
      end: endDate.toISOString().split('T')[0]
    }
  }
}

// getDailyCashFlow
export async function getDailyCashFlow(date: Date): Promise<CashFlowEntry[]> {
  const supabase = createClient()
  const dateStr = date.toISOString().split('T')[0]

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  const { data, error } = await supabase
    .from('cash_flow')
    .select('*')
    .eq('transaction_date', dateStr)
    .order('created_at', { ascending: false })

  if (error) throw error
  return data || []
}

// getReceivablesForecast
export async function getReceivablesForecast(
  months: number = 3
): Promise<ReceivablesForecast[]> {
  const supabase = createClient()
  const today = new Date()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  // Calcular data limite
  const limitDate = new Date(today)
  limitDate.setMonth(limitDate.getMonth() + months)

  const { data, error } = await supabase
    .from('sale_installments')
    .select('amount, paid_amount, due_date')
    .in('status', ['pending', 'partial'])
    .gte('due_date', today.toISOString().split('T')[0])
    .lte('due_date', limitDate.toISOString().split('T')[0])

  if (error) throw error

  // Agrupar por mês
  const byMonth: Record<string, { expected: number; count: number }> = {}

  data?.forEach(item => {
    const month = item.due_date.substring(0, 7) // 'YYYY-MM'
    if (!byMonth[month]) {
      byMonth[month] = { expected: 0, count: 0 }
    }
    byMonth[month].expected += (item.amount - item.paid_amount)
    byMonth[month].count++
  })

  // Converter para array ordenado
  return Object.entries(byMonth)
    .map(([month, data]) => ({
      month,
      expected: Number(data.expected.toFixed(2)),
      count: data.count
    }))
    .sort((a, b) => a.month.localeCompare(b.month))
}

// getCashFlowMetrics
export async function getCashFlowMetrics(): Promise<CashFlowMetrics> {
  const supabase = createClient()
  const today = new Date()
  const todayStr = today.toISOString().split('T')[0]

  // Primeiro dia da semana (domingo)
  const weekStart = new Date(today)
  weekStart.setDate(today.getDate() - today.getDay())

  // Primeiro dia do mês
  const monthStart = new Date(today.getFullYear(), today.getMonth(), 1)

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  // Query cash_flow para métricas
  const { data: cashData, error: cashError } = await supabase
    .from('cash_flow')
    .select('amount, transaction_date')
    .eq('type', 'income')
    .gte('transaction_date', monthStart.toISOString().split('T')[0])

  if (cashError) throw cashError

  // Query parcelas para receivables
  const { data: installmentData, error: installmentError } = await supabase
    .from('sale_installments')
    .select('amount, paid_amount, status, due_date')
    .in('status', ['pending', 'partial', 'overdue'])

  if (installmentError) throw installmentError

  // Calcular métricas de cash
  let todayTotal = 0
  let weekTotal = 0
  let monthTotal = 0

  cashData?.forEach(item => {
    monthTotal += item.amount
    if (item.transaction_date >= weekStart.toISOString().split('T')[0]) {
      weekTotal += item.amount
    }
    if (item.transaction_date === todayStr) {
      todayTotal += item.amount
    }
  })

  // Calcular receivables
  let pendingReceivables = 0
  let overdueReceivables = 0

  installmentData?.forEach(item => {
    const remaining = item.amount - item.paid_amount
    if (item.due_date < todayStr || item.status === 'overdue') {
      overdueReceivables += remaining
    } else {
      pendingReceivables += remaining
    }
  })

  return {
    today: Number(todayTotal.toFixed(2)),
    thisWeek: Number(weekTotal.toFixed(2)),
    thisMonth: Number(monthTotal.toFixed(2)),
    pendingReceivables: Number(pendingReceivables.toFixed(2)),
    overdueReceivables: Number(overdueReceivables.toFixed(2))
  }
}

// getCashFlowGrouped
export async function getCashFlowGrouped(
  startDate: Date,
  endDate: Date,
  groupBy: 'day' | 'week' | 'month' = 'day'
): Promise<GroupedCashFlow[]> {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Usuário não autenticado')

  const { data, error } = await supabase
    .from('cash_flow')
    .select('type, amount, transaction_date')
    .gte('transaction_date', startDate.toISOString().split('T')[0])
    .lte('transaction_date', endDate.toISOString().split('T')[0])

  if (error) throw error

  // Agrupar dados
  const grouped: Record<string, GroupedCashFlow> = {}

  data?.forEach(item => {
    let period: string

    switch (groupBy) {
      case 'month':
        period = item.transaction_date.substring(0, 7) // 'YYYY-MM'
        break
      case 'week':
        const date = new Date(item.transaction_date)
        const weekStart = new Date(date)
        weekStart.setDate(date.getDate() - date.getDay())
        period = weekStart.toISOString().split('T')[0]
        break
      default: // day
        period = item.transaction_date
    }

    if (!grouped[period]) {
      grouped[period] = {
        period,
        income: 0,
        expense: 0,
        balance: 0,
        count: 0
      }
    }

    if (item.type === 'income') {
      grouped[period].income += item.amount
    } else {
      grouped[period].expense += item.amount
    }
    grouped[period].count++
  })

  // Calcular balance e ordenar
  return Object.values(grouped)
    .map(g => ({
      ...g,
      income: Number(g.income.toFixed(2)),
      expense: Number(g.expense.toFixed(2)),
      balance: Number((g.income - g.expense).toFixed(2))
    }))
    .sort((a, b) => a.period.localeCompare(b.period))
}
```

### Exemplo de Respostas

[Source: docs/architecture-cash-flow.md#6.2.2]

```typescript
// getCashFlowMetrics()
{
  today: 1500.00,
  thisWeek: 4200.00,
  thisMonth: 15800.00,
  pendingReceivables: 3200.00,
  overdueReceivables: 487.00
}

// getReceivablesForecast(3)
[
  { month: '2025-12', expected: 2430.00, count: 5 },
  { month: '2026-01', expected: 1820.00, count: 4 },
  { month: '2026-02', expected: 890.00, count: 2 }
]
```

### Testing

- Testar `getCashFlowByPeriod` com diferentes intervalos
- Testar `getCashFlowMetrics` comparando com dados manuais
- Testar `getReceivablesForecast` com parcelas em meses diferentes
- Verificar arredondamento de valores decimais
- Testar RLS entre usuários diferentes

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-29 | 1.0 | Story criada a partir do PRD | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_A ser preenchido pelo dev agent_

### Debug Log References
_A ser preenchido pelo dev agent_

### Completion Notes
_A ser preenchido pelo dev agent_

### File List
_A ser preenchido pelo dev agent_

---

## QA Results
_A ser preenchido pelo QA agent_
