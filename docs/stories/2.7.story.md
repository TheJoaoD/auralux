# Story 2.7: Migração de Vendas Parceladas Existentes

## Status: Draft

## Story

**As a** administrador,
**I want** que vendas parceladas já registradas sejam convertidas para o novo modelo,
**so that** eu tenha histórico completo no sistema de parcelas.

## Acceptance Criteria

1. Script identifica vendas com `payment_method: 'installment'`
2. Para cada venda, cria parcelas retroativas baseadas em `installment_count`
3. Parcelas passadas são marcadas como 'paid' (assumindo que foram pagas)
4. Registros correspondentes criados no `cash_flow`
5. Campo `payment_status` atualizado para 'paid' nas vendas migradas
6. Log de migração para auditoria
7. Script é idempotente (pode rodar múltiplas vezes sem duplicar)

## Integration Verification

- IV1: Dados existentes não são perdidos ou corrompidos
- IV2: Vendas à vista não são afetadas
- IV3: Métricas históricas permanecem consistentes

## Tasks / Subtasks

- [ ] **Task 1: Criar script de migração SQL** (AC: 1, 2, 3, 4, 5, 7)
  - [ ] Identificar vendas parceladas sem parcelas criadas
  - [ ] Calcular valor de cada parcela
  - [ ] Calcular datas de vencimento retroativas
  - [ ] Inserir parcelas como 'paid'
  - [ ] Criar entries no cash_flow
  - [ ] Atualizar payment_status da venda
  - [ ] Usar condição NOT EXISTS para idempotência

- [ ] **Task 2: Criar função de migração alternativa (TypeScript)** (AC: 1-7)
  - [ ] Criar script em `scripts/migrate-installments.ts`
  - [ ] Buscar vendas parceladas sem parcelas
  - [ ] Para cada venda:
    - [ ] Calcular parcelas
    - [ ] Inserir em sale_installments
    - [ ] Inserir em cash_flow
    - [ ] Atualizar venda
  - [ ] Log de cada venda processada
  - [ ] Tratamento de erros

- [ ] **Task 3: Criar log de migração** (AC: 6)
  - [ ] Tabela temporária ou arquivo de log
  - [ ] Registrar: sale_id, parcelas criadas, valores, timestamp
  - [ ] Permitir auditoria posterior

- [ ] **Task 4: Testar em ambiente de desenvolvimento** (IV1, IV2, IV3)
  - [ ] Backup dos dados antes de testar
  - [ ] Executar migração
  - [ ] Verificar parcelas criadas corretamente
  - [ ] Verificar cash_flow entries
  - [ ] Verificar vendas à vista não afetadas
  - [ ] Re-executar script (testar idempotência)

- [ ] **Task 5: Criar verificação pós-migração** (AC: 7)
  - [ ] Query para verificar vendas sem parcelas
  - [ ] Query para verificar inconsistências
  - [ ] Relatório de migração

- [ ] **Task 6: Executar em produção**
  - [ ] Fazer backup completo
  - [ ] Executar migration via Supabase MCP
  - [ ] Verificar resultados
  - [ ] Validar totais

## Dev Notes

### Dependências

- **Requer**: Stories 2.1-2.4 completas (tabelas e services existentes)
- **Execução**: Via Supabase MCP `apply_migration` ou SQL direto

### Script SQL Completo de Migração

[Source: docs/architecture-cash-flow.md#4.5]

```sql
-- ============================================
-- MIGRATION: Migrar Vendas Parceladas Existentes
-- IMPORTANTE: Executar em transação, é IDEMPOTENTE
-- ============================================

DO $$
DECLARE
  sale_record RECORD;
  installment_amount DECIMAL(10,2);
  installment_date DATE;
  new_installment_id UUID;
  i INTEGER;
  migrated_count INTEGER := 0;
BEGIN
  RAISE NOTICE 'Iniciando migração de vendas parceladas...';

  -- Iterar vendas parceladas SEM parcelas já criadas
  FOR sale_record IN
    SELECT s.*
    FROM sales s
    WHERE s.payment_method = 'installment'
      AND s.installment_count > 0
      AND NOT EXISTS (
        SELECT 1 FROM sale_installments si WHERE si.sale_id = s.id
      )
  LOOP
    RAISE NOTICE 'Migrando venda %: % parcelas de R$ %',
      sale_record.id,
      sale_record.installment_count,
      sale_record.total_amount;

    -- Calcular valor de cada parcela
    installment_amount := ROUND(sale_record.total_amount / sale_record.installment_count, 2);

    -- Criar parcelas
    FOR i IN 1..sale_record.installment_count LOOP
      -- Data de vencimento: data da venda + (i-1) meses
      installment_date := (sale_record.created_at::DATE + ((i - 1) * INTERVAL '1 month'))::DATE;

      -- Inserir parcela como PAGA
      INSERT INTO sale_installments (
        id,
        sale_id,
        user_id,
        installment_number,
        amount,
        due_date,
        status,
        paid_amount,
        paid_at,
        payment_method,
        notes,
        created_at,
        updated_at
      ) VALUES (
        gen_random_uuid(),
        sale_record.id,
        sale_record.user_id,
        i,
        installment_amount,
        installment_date,
        'paid',  -- Assumir pagas (histórico)
        installment_amount,
        installment_date + INTERVAL '1 day',  -- Assumir paga no dia seguinte ao vencimento
        'migrated',
        'Parcela migrada automaticamente do histórico'
      )
      RETURNING id INTO new_installment_id;

      -- Criar registro no cash_flow
      INSERT INTO cash_flow (
        id,
        user_id,
        type,
        category,
        amount,
        description,
        reference_type,
        reference_id,
        transaction_date,
        created_at,
        created_by
      ) VALUES (
        gen_random_uuid(),
        sale_record.user_id,
        'income',
        'installment_payment',
        installment_amount,
        FORMAT('Parcela %s/%s - Venda migrada', i, sale_record.installment_count),
        'installment',
        new_installment_id,
        installment_date,
        NOW(),
        sale_record.user_id
      );
    END LOOP;

    -- Atualizar status da venda
    UPDATE sales
    SET
      payment_status = 'paid',
      down_payment = 0,
      updated_at = NOW()
    WHERE id = sale_record.id;

    migrated_count := migrated_count + 1;
  END LOOP;

  RAISE NOTICE 'Migração concluída. Total de vendas migradas: %', migrated_count;
END $$;
```

### Script TypeScript Alternativo

```typescript
// scripts/migrate-installments.ts
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!

const supabase = createClient(supabaseUrl, supabaseServiceKey)

interface SaleToMigrate {
  id: string
  user_id: string
  total_amount: number
  installment_count: number
  created_at: string
}

async function migrateInstallments() {
  console.log('Iniciando migração de vendas parceladas...')

  // Buscar vendas parceladas sem parcelas
  const { data: salesToMigrate, error: fetchError } = await supabase
    .from('sales')
    .select('id, user_id, total_amount, installment_count, created_at')
    .eq('payment_method', 'installment')
    .gt('installment_count', 0)
    .not('id', 'in', supabase
      .from('sale_installments')
      .select('sale_id')
    )

  if (fetchError) {
    console.error('Erro ao buscar vendas:', fetchError)
    return
  }

  console.log(`Encontradas ${salesToMigrate?.length || 0} vendas para migrar`)

  for (const sale of (salesToMigrate || []) as SaleToMigrate[]) {
    await migrateSale(sale)
  }

  console.log('Migração concluída!')
}

async function migrateSale(sale: SaleToMigrate) {
  console.log(`Migrando venda ${sale.id}...`)

  const installmentAmount = Number((sale.total_amount / sale.installment_count).toFixed(2))
  const startDate = new Date(sale.created_at)

  const installments = []
  const cashFlowEntries = []

  for (let i = 1; i <= sale.installment_count; i++) {
    const dueDate = new Date(startDate)
    dueDate.setMonth(dueDate.getMonth() + (i - 1))
    const dueDateStr = dueDate.toISOString().split('T')[0]

    const installmentId = crypto.randomUUID()

    installments.push({
      id: installmentId,
      sale_id: sale.id,
      user_id: sale.user_id,
      installment_number: i,
      amount: installmentAmount,
      due_date: dueDateStr,
      status: 'paid',
      paid_amount: installmentAmount,
      paid_at: new Date(dueDate.getTime() + 86400000).toISOString(), // +1 dia
      payment_method: 'migrated',
      notes: 'Parcela migrada automaticamente do histórico'
    })

    cashFlowEntries.push({
      user_id: sale.user_id,
      type: 'income',
      category: 'installment_payment',
      amount: installmentAmount,
      description: `Parcela ${i}/${sale.installment_count} - Venda migrada`,
      reference_type: 'installment',
      reference_id: installmentId,
      transaction_date: dueDateStr,
      created_by: sale.user_id
    })
  }

  // Inserir parcelas
  const { error: installmentError } = await supabase
    .from('sale_installments')
    .insert(installments)

  if (installmentError) {
    console.error(`Erro ao inserir parcelas da venda ${sale.id}:`, installmentError)
    return
  }

  // Inserir cash_flow
  const { error: cashFlowError } = await supabase
    .from('cash_flow')
    .insert(cashFlowEntries)

  if (cashFlowError) {
    console.error(`Erro ao inserir cash_flow da venda ${sale.id}:`, cashFlowError)
    return
  }

  // Atualizar venda
  const { error: updateError } = await supabase
    .from('sales')
    .update({
      payment_status: 'paid',
      down_payment: 0
    })
    .eq('id', sale.id)

  if (updateError) {
    console.error(`Erro ao atualizar venda ${sale.id}:`, updateError)
    return
  }

  console.log(`✓ Venda ${sale.id} migrada: ${sale.installment_count} parcelas`)
}

// Executar
migrateInstallments()
```

### Queries de Verificação

```sql
-- 1. Verificar vendas parceladas sem parcelas (deve retornar 0 após migração)
SELECT COUNT(*)
FROM sales s
WHERE s.payment_method = 'installment'
  AND s.installment_count > 0
  AND NOT EXISTS (
    SELECT 1 FROM sale_installments si WHERE si.sale_id = s.id
  );

-- 2. Verificar consistência de valores
SELECT
  s.id,
  s.total_amount,
  s.installment_count,
  SUM(si.amount) as total_parcelas,
  s.total_amount - SUM(si.amount) as diferenca
FROM sales s
JOIN sale_installments si ON si.sale_id = s.id
WHERE s.payment_method = 'installment'
GROUP BY s.id
HAVING ABS(s.total_amount - SUM(si.amount)) > 0.01;

-- 3. Verificar vendas à vista (não devem ter parcelas)
SELECT s.id
FROM sales s
JOIN sale_installments si ON si.sale_id = s.id
WHERE s.payment_method != 'installment';

-- 4. Total de parcelas migradas
SELECT COUNT(*)
FROM sale_installments
WHERE payment_method = 'migrated';

-- 5. Total de cash_flow entries de migração
SELECT COUNT(*)
FROM cash_flow
WHERE description LIKE '%Venda migrada%';
```

### Passos de Execução Recomendados

1. **Backup**: Fazer backup completo do banco via Supabase Dashboard
2. **Teste local**: Se possível, testar em ambiente de desenvolvimento
3. **Verificação prévia**: Rodar query 1 para ver quantas vendas serão migradas
4. **Executar migração**: Via Supabase MCP `apply_migration`
5. **Verificação pós**: Rodar queries 1-5 para validar
6. **Testar UI**: Verificar que parcelas aparecem corretamente

### Rollback (se necessário)

```sql
-- CUIDADO: Este script reverte a migração
-- Use apenas se houver problemas

-- 1. Deletar parcelas migradas
DELETE FROM sale_installments
WHERE payment_method = 'migrated';

-- 2. Deletar cash_flow de migração
DELETE FROM cash_flow
WHERE description LIKE '%Venda migrada%';

-- 3. Resetar payment_status das vendas
UPDATE sales
SET payment_status = NULL, down_payment = NULL
WHERE payment_method = 'installment';
```

### Testing

- Testar script em ambiente de dev primeiro
- Verificar que parcelas têm valores e datas corretos
- Verificar que cash_flow entries foram criados
- Re-executar script e verificar que não duplica dados
- Verificar que vendas à vista não foram afetadas

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-29 | 1.0 | Story criada a partir do PRD | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_A ser preenchido pelo dev agent_

### Debug Log References
_A ser preenchido pelo dev agent_

### Completion Notes
_A ser preenchido pelo dev agent_

### File List
_A ser preenchido pelo dev agent_

---

## QA Results
_A ser preenchido pelo QA agent_
